from pwn import *
from tqdm import tqdm
from Crypto.Util.Padding import pad
from typing import List

context.log_level = 'error'

HOST = "46.101.81.60"
PORT = 31775
BLOCK_SIZE = 16

def is_valid_padding(c_target: str, dec_ci: bytearray, m_prime: int, c_prev_prime: int) -> bool:
    """
    Check if the padding is valid through the app by chainging the ciphertext

    :param c_target: The target ciphertext block as a hex string
    :param dec_ci: Decrypted block (intermediate state) as a bytearray
    :param m_prime: The byte position (1-indexed) being attacked in the current block
    :param c_prev_prime: The modified byte value for the previous block's corresponding byte position
    :return: boolean if the padding is valid
    """
    r = remote(HOST, PORT)
    # here is not important because the leaked cipher text is not our concerns.
    r.sendafter("username: ", "foo")
    r.sendafter("password: ", "bar")

    # ex. 00000000000000000046
    attempt_byte = b"\x00" * (BLOCK_SIZE-m_prime) + p8(c_prev_prime)
    adjusted_bytes = b""
    for c in dec_ci:
        adjusted_bytes += p8(c ^ m_prime)
    
    r.sendafter("enter ciphertext: ", attempt_byte.hex() + adjusted_bytes.hex() + c_target)
    res = r.recvall()
    return "incorrect" not in res.decode()

def send_cipher(cipher_text: str):
    r = remote(HOST, PORT)
    r.sendafter("username: ", "admin")
    r.sendafter("password: ", "g0ld3n_b0x")
    r.sendafter("enter ciphertext: ", cipher_text)
    res = r.recvall()
    print(res.decode())

def create_cipher(plain_block: List[str], dec_block: List[str]) -> str:
    """
    Creates a ciphertext by XORing corresponding plain and decrypted blocks, and appends a block of zeros.

    :param plain_block: A list of plaintext block hex strings
    :param dec_block: A list of decrypted block hex strings
    :return: The resulting ciphertext as a hex string
    """
    c0 = format(int(plain_block[0],16) ^ int(dec_block[2],16),'x').zfill(BLOCK_SIZE*2)
    c1 = format(int(plain_block[1],16) ^ int(dec_block[1],16),'x').zfill(BLOCK_SIZE*2)
    c2 = format(int(plain_block[2],16) ^ int(dec_block[0],16),'x').zfill(BLOCK_SIZE*2)
    c3 = "00" * BLOCK_SIZE
    return c0 + c1 + c2 + c3

def encryption_attack() -> str:
    # initial Dec(ci) value. This value will be updated.
    initial = "00" * BLOCK_SIZE
    target_plain_text = "logged_username=admin&password=g0ld3n_b0y"
    plain = pad(target_plain_text.encode(),16,style='pkcs7').hex()

    plain_block = [plain[i: i+BLOCK_SIZE*2] for i in range(0, len(plain), BLOCK_SIZE*2)]
    dec_block = [initial] * len(plain_block)

    cipher_text = create_cipher(plain_block, dec_block)
    cipher_text = cipher_text.zfill(len(cipher_text) + len(cipher_text) % BLOCK_SIZE*2)

    # split cipher_text into ciphe_block by BLOCK_SIZE * 2
    cipher_block = [cipher_text[i: i+BLOCK_SIZE*2] for i in range(0, len(cipher_text), BLOCK_SIZE*2)]
    cipher_block.reverse()

    for i in tqdm(range(len(cipher_block)-1)):
        c_target = cipher_block[0]
        c_prev = cipher_block[1]
        
        print("c_prev: {}".format(c_prev))
        print("c_target: {}".format(c_target))
        cipher_block.pop(0)

        m_prime = 1
        c_prev_prime = 0
        dec_ci = b""  # Dec(ci)

        while True:
            if is_valid_padding(c_target, dec_ci, m_prime, c_prev_prime):
                print("0x{:02x}: ".format(c_prev_prime) + "{:02x}".format(m_prime) * m_prime)
                dec_ci = p8(c_prev_prime ^ m_prime) + dec_ci
                m_prime += 1
                c_prev_prime = 0
                if m_prime <= BLOCK_SIZE:
                    continue
                break
            c_prev_prime += 1
            if c_prev_prime > 0xff:
                print("Not Found")
                break
        dec_block[i] = dec_ci.hex().zfill(BLOCK_SIZE*2)
        cipher_text = create_cipher(plain_block, dec_block)
        cipher_block = [cipher_text[j: j+BLOCK_SIZE*2] for j in range(0, len(cipher_text), BLOCK_SIZE*2)]
        cipher_block.reverse()
        for _ in range(i+1):
            cipher_block.pop(0)
    tempered_cipher = create_cipher(plain_block, dec_block)
    print("[+] tempered cipher text:", tempered_cipher)

    return tempered_cipher

if __name__ == "__main__":
    cipher_text = encryption_attack()
    send_cipher(cipher_text)